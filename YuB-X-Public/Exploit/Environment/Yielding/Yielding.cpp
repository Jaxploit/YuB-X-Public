#include <Exploit/Globals.hpp>
#include <Exploit/Environment/Yielding/Yielding.hpp>

void YieldWorker(lua_State* L, const std::function<Yielded()>& YieldingClosure)
{
	auto YieldResult = YieldingClosure();
	int ResultCount = YieldResult(L);

	lua_State* YieldThread = lua_newthread(L);

	lua_getglobal(YieldThread, "task");
	lua_getfield(YieldThread, -1, "defer");
	lua_pushthread(L);
	lua_xmove(L, YieldThread, 1);
	lua_pop(L, 1);

	for (int i = ResultCount; i >= 1; --i)
	{
		lua_pushvalue(L, -i);
		lua_xmove(L, YieldThread, 1);
	}

	lua_pcall(YieldThread, ResultCount + 1, 0, 0);
	lua_settop(YieldThread, 0);
}

int Yielding::YieldExecution(lua_State* L, const std::function<Yielded()>& YieldingClosure)
{
	lua_pushthread(L);
	lua_ref(L, -1);
	lua_pop(L, 1);

	std::thread(YieldWorker, L, YieldingClosure).detach();

	L->base = L->top;
	L->status = LUA_YIELD;
	L->ci->flags |= 1;

	return -1;
}