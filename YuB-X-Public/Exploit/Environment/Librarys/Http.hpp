#pragma once

#include <Windows.h>
#include <lstate.h>
#include <lgc.h>
#include <lualib.h>
#include <sstream>

#include <cpr/cpr.h>
#include <Exploit/Utils.hpp>
#include <Dependencies/nlohmann/json.hpp>
#include <Exploit/Environment/Yielding/Yielding.hpp>

namespace Http
{
    int HttpGet(lua_State* L)
    {
        std::string Url;

        if (!lua_isstring(L, 1))
        {
            luaL_checkstring(L, 2);
            Url = lua_tostring(L, 2);
        }
        else
        {
            Url = lua_tostring(L, 1);
        }

        std::string UrlStr(Url);
        if (UrlStr.find("http://") != 0 && UrlStr.find("https://") != 0)
        {
            luaL_argerror(L, 2, "Invalid protocol (expected 'http://' or 'https://')");
            return 0;
        }

        std::string GameId;
        lua_getglobal(L, "game");
        if (lua_istable(L, -1))
        {
            lua_getfield(L, -1, "GameId");
            if (lua_isstring(L, -1))
                GameId = lua_tostring(L, -1);
            lua_pop(L, 1);
        }
        lua_pop(L, 1);

        std::string PlaceId;
        lua_getglobal(L, "game");
        if (lua_istable(L, -1))
        {
            lua_getfield(L, -1, "PlaceId");
            if (lua_isstring(L, -1))
                PlaceId = lua_tostring(L, -1);
            lua_pop(L, 1);
        }
        lua_pop(L, 1);

        std::optional<std::string> HWID;
        HW_PROFILE_INFO hwProfileInfo;
        GetCurrentHwProfile(&hwProfileInfo);

        using Json = nlohmann::json;
        cpr::Header Headers;
        Json SessionIdJson;

        SessionIdJson["GameId"] = GameId;
        SessionIdJson["PlaceId"] = PlaceId;

        Headers.insert({ "User-Agent", "Roblox/WinInet" });
        Headers.insert({ "Roblox-Session-Id", SessionIdJson.dump() });
        Headers.insert({ "Roblox-Place-Id", PlaceId });
        Headers.insert({ "Roblox-Game-Id", GameId });
        Headers.insert({ "Exploit-Identifier", "YuB-X-Public" });
        Headers.insert({ "Exploit-Guid", HWID.value_or("Unknown") });
        Headers.insert({ "YuB-X-Fingerprint", HWID.value_or("Unknown") });
        Headers.insert({ "Accept", "*/*" });

        return Yielding::YieldExecution(L, [UrlStr, Headers]() -> std::function<int(lua_State*)>
        {
            cpr::Response Result;
            try
            {
                Result = cpr::Get(cpr::Url{ UrlStr }, cpr::Header(Headers));
            }
            catch (const std::exception& ex)
            {
                std::stringstream err;
                err << "HttpGet failed: " << ex.what();
                std::string errStr = err.str();
                return [errStr](lua_State* L) -> int
                {
                    lua_pushstring(L, errStr.c_str());
                    return 1;
                };
            }
            catch (...)
            {
                return [](lua_State* L) -> int
                {
                    lua_pushstring(L, "HttpGet failed: unknown exception");
                    return 1;
                };
            }

            return [Result, UrlStr](lua_State* L) -> int
            {
                if (Result.error.code != cpr::ErrorCode::OK)
                {
                    std::stringstream err;
                    err << "HttpGet failed: " << Result.error.message << ", Code: " << Result.status_code;
                    std::string errStr = err.str();
                    lua_pushstring(L, errStr.c_str());
                    return 1;
                }

                if (Result.status_code != 200)
                {
                    std::stringstream err;
                    err << "HttpGet returned status: " << Result.status_code << ", Error: " << Result.error.message;
                    std::string errStr = err.str();
                    lua_pushstring(L, errStr.c_str());
                    return 1;
                }

                lua_pushlstring(L, Result.text.data(), Result.text.size());
                return 1;
            };
        });
    }

    void RegisterLibrary(lua_State* L)
    {
        Utils::AddFunction(L, "HttpGet", Http::HttpGet);
    }
}